<!--
title: Zones
date: 2015/08/31
id: e958b17d-651a-4739-a24e-c0ea6114f2d8
category: Изучение Dart
icon: dart_learning
labels:
  - Dart
  - Zones
-->

Часто, программа генерирует не перехваченное исключение и прекращает выполнение. Это может означать что код работает не правильно и его нужно исправить. Но иногда исключения могут происходить по ошибке коммуникации, аппаратных сбоев и тому подобное. Для демонстрации проблемы, используем *HTTP* сервер в качестве примера:

```language-dart

import 'dart:io';

main() {
  runServer();
}

runServer() {
  HttpServer
  .bind(InternetAddress.ANY_IP_V4, 8080)
  .then((server) {
    server.listen((HttpRequest request) {
      request.response.write('Hello, world!');
      request.response.close();
    });
  });
}

```

В случае возникновения ошибок в функции *runServer*, выполнение кода в главной функции *main* может быть остановлено. Завершение программы в таких случаях может быть не желательно.

Как можно решить эту проблему? Мы можем обернуть наш код в блок **try/catch** и перехватить все исключения, и тогда всё будет работать отлично:

```language-dart

main() {
  try {
    runServer();
  } on Error catch(e) {
    // ...
  } 
}

```

Это универсальное решение и используется часто. Поэтому будет лучше написать для этого отдельную функцию (*wrapper*):

```language-dart

wrapper(Function body, {Function onError}) {
  try {
    body();
  } on Error catch(e) {
    if (onError != null) {
      onError(e);
    }

  }
}

main() {
  wrapper(runServer, onError:(e) {
    // ...
  });
}

```

Аргумент *body* представляет собой любой код, который находится в блоке *try/catch* внутри *wrapper*. Функция **wrapper** использует функцию *onError* для обработки всех пойманных исключений. Использование **wrapper** - хорошая практика, её использование рекомендуется и в других подобных ситуациях. Это и есть **Zone**.

>**Заметка:** **Zone** это настраиваемый контекст выполнения, который обрабатывает асинхронные задачи и пойманные исключения.

Что зоны могут:

 - в критичных ситуациях, они позволяют обрабатывать исключения правильно
 - дают возможность обработки нескольких асинхронных операций в одной группе
 - могут иметь неограниченное количество вложенных зон

Каждая зона создаёт контекст, вроде защищённой территории, где находится выполняемый код. В дополнение ко всему, зоны имеют локальные переменные и могут определять *microtasks*, создавать одноразовые или повторяющиeся таймеры, выводить информацию, и сохранять *трасировку стека (stack trace)* для отладки.
