<!--
title: Асинхронное программирование
date: 2015/08/20
id: 40f72d3f-fb12-4a75-a94a-10ec97014588
category: Изучение Dart
icon: dart_learning
labels:
  - Dart
  - Async
-->

Мы рассмотрим передовые технологии, которые помогут нам работать с асинхронным кодом - одним из самых важнейших компонентов Dart. Асинхронное программирование является стандартной парадигмой программирования вместе с объектно-ориентированными принципами и играет важную роль в разработке приложений.

<p><a href="{{site.url}}/posts/2015/08/05/The_Dart_Vm_execution_model.html">Про модель исполнения кода в Dart VM можно прочитать здесь.</a></p>

Для лучшего понимания асинхронного программирования в Dart мы рассмотрим архитектуры **стека вызова (call-stack)** и **управляемых событий (event-driven)**. 

## Call-stack архитектура
Традиционно, программы строятся на концепции **стека вызовов**. Эта концепция очень проста, потому как программа в основном выполняет и вызывает последовательные операции. Каждая операция может выполнить другую операцию. В момент вызова программа создаёт контекст для выполняемой операции. Вызвавшая операция будет ждать пока вызываемая операция закончит работу и тогда программа сможет вернуть контекст для продолжения её выполнения. Вызываемая операция со своей стороны может выполнять ещё операцию.

Программа создаёт стек вызова для координации и управления контекстом каждого вызова. Основные примитивы этой концепции - вызовы (calls). Все вызовы в программе тесно связанны, потому что программа знает какие операции должны быть вызваны после текущей вызываемой операции и может поделить одну и ту же память. Архитектура стека вызова очень распространена и популярна, потому что очень похоже на архитектуру процессоров.

##Event-driven архитектура
Архитектура управляемых событий полная противоположность концепции стека вызова. Основные примитивы этой концепции - события (events). Система отправляет события и передает их среди слабосвязанных компонентов программного обеспечения и ёё служб. К преимуществам **event-driven архитектуры (EDA)** можно отнести следующее:

- Помогает использовать существующие ресурсы эффективно.
- Архитектура проста в расширении, развитии и поддержке, снижая стоимость обслуживания.
- Позволяет обмениваться сообщениями в асинхронном режиме, что предотвращает блокировку или ожидание очереди.
- Слабая связь между производящим кодом и выполняющим.

Взаимодействие между компонентами ограничено лишь производящей событие операции и одним или несколькими выполняющими. Операции, производящие события, чувствуют себя свободно от проблем параллелизма и проблем синхронизации. Выполняющие операции могут быть изменены в любой момент, так как производящие и выполняющие операции слабо связанны друг с другом. 

> **Заметка**: Событийная архитектура это правильный выбор для разработки слабозависимых асинхронных систем.

<br><br>

##Синхронный и асинхронный код
Есть много разговоров о том, какой код лучше синхронный или асинхронный. Все разговоры останавливаются на дизайне архитектуры. Следовательно, важным вопросом будет какая разница в синхронных и асинхронных конструкциях кода?

Обсудим условия того что мы будем делать. Операции будут выполняться последовательно в синхронном **(sync)** коде. Не больше, не меньше. Это очень популярно потому что это просто. Логика синхронного кода ясна, и мы можем прочитать и понять его без особых усилий. Взглянем на следующий фрагмент кода:

```language-dart

import 'dart:io';

main() {
  try {
    File file = new File("data.txt");
    RandomAccessFile handler = file.openSync();
    List<int> content = handler.readSync(handler.lengthSync());
    String contentAsString = new String.fromCharCodes(content);
    print("Content:  $contentAsString");
    handler.closeSync();
  } on FileSystemException catch(e) {
    print(e.message);
  }
}

```

<p class="column">
Во-первых, мы создаем переменную указывающую на файл <em>data.txt</em> в файловой системе. Далее, мы создаем обработчик открыв этот файл. Затем, обработчик считывает байты открытого файла в переменную <em>content</em>. И на конец, мы переводим содержание переменной <em>content</em> в строку, печатаем результат, и закрываем обработчик для файла. Некоторые операции в этом коде занимают больше времени чем другие. Операция чтения файла может быть быстрой только в случаях когда размер файла маленький. Если файл большой то программа будет ожидать пока файл не будет считан. Для перевода содержимого файла может потребоваться некоторое время. Такие операции блокируют выполнение нашей программы; каждый раз такая операция должна завершаться до того как начнется выполнение другой. Такой код реализован на синхронный манер, и может быть полезен при выполнении простых задач таких как эта. Тем не менее, такой подход не может быть применён в комплексном программном обеспечении. Комплексная программа может иметь различные части кода которые могут взаимодействовать между собой для обеспечения удобного интерфейса пользователя <strong>(UI)</strong>, обработки процесса ввода с клавиатуры, для чтения информации с удалённого сайта и в тоже время записи информации в файл. Таким образом, пришло время обсудить модный асинхронный <strong>(async)</strong> код. Асинхронный код не ждет завершения каждой операции; Результат каждой операции будет обработан позже, когда станет доступным. Асинхронный код использует несколько важных классов в Dart SDK и один из них <strong>Future</strong>.
</p>

