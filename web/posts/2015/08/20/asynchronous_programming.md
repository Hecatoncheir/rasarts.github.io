<!--
title: Асинхронное программирование
date: 2015/08/20
id: 40f72d3f-fb12-4a75-a94a-10ec97014588
category: Изучение Dart
icon: dart_learning
labels:
  - Dart
  - Async
-->

Мы рассмотрим передовые технологии, которые помогут нам работать с асинхронным кодом - одним из самых важнейших компонентов Dart. Асинхронное программирование является стандартной парадигмой программирования вместе с объектно-ориентированными принципами и играет важную роль в разработке приложений.

<a href="{{site.url}}/posts/2015/08/05/The_Dart_Vm_execution_model.html">Про модель исполнения кода в Dart VM можно прочитать здесь.</a>

Для лучшего понимания асинхронного программирования в Dart мы рассмотрим архитектуры **стека вызова (call-stack)** и **управляемых событий (event-driven)**. 

## Call-stack архитектура
Традиционно, программы строятся на концепции **стека вызовов**. Эта концепция очень проста, потому как программа в основном выполняет и вызывает последовательные операции. Каждая операция может выполнить другую операцию. В момент вызова программа создаёт контекст для выполняемой операции. Вызвавшая операция будет ждать пока вызываемая операция закончит работу и тогда программа сможет вернуть контекст для продолжения её выполнения. Вызываемая операция со своей стороны может выполнять ещё операцию.

Программа создаёт стек вызова для координации и управления контекстом каждого вызова. Основные примитивы этой концепции - вызовы (calls). Все вызовы в программе тесно связанны, потому что программа знает какие операции должны быть вызваны после текущей вызываемой операции и может поделить одну и ту же память. Архитектура стека вызова очень распространена и популярна, потому что очень похоже на архитектуру процессоров.

##Event-driven архитектура
Архитектура управляемых событий полная противоположность концепции стека вызова. Основные примитивы этой концепции - события (events). Система отправляет события и передает их среди слабосвязанных компонентов программного обеспечения и ёё служб. К преимуществам **event-driven архитектуры (EDA)** можно отнести следующее:

- Помогает использовать существующие ресурсы эффективно.
- Архитектура проста в расширении, развитии и поддержке, снижая стоимость обслуживания.
- Позволяет обмениваться сообщениями в асинхронном режиме, что предотвращает блокировку или ожидание очереди.
- Слабая связь между производящим кодом и выполняющим.

Взаимодействие между компонентами ограничено лишь производящей событие операции и одним или несколькими выполняющими. Операции, производящие события, чувствуют себя свободно от проблем параллелизма и проблем синхронизации. Выполняющие операции могут быть изменены в любой момент, так как производящие и выполняющие операции слабо связанны друг с другом. 

> **Заметка**: Событийная архитектура это правильный выбор для разработки слабозависимых асинхронных систем.
